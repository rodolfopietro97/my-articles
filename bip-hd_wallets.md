# Wallet
* Wallet store keys, NOT money (money are stored in the blockchain (UTXO -> Unspent Transactions Output)).
* With private key I unlock UTXO and i Sign transactions
* Public address is derived by private key

![](https://www.researchgate.net/profile/Nazri-Abdullah-2/publication/291788014/figure/fig3/AS:421746537963523@1477563618253/Generation-Protocol-for-Bitcoin-Addresses.png)

## Non deterministic wallet
* Wallet stores private keys, BUT also create private keys
* It generate **RANDOMLY** a set of private keys (consequently we have public keys and address)
* **NON DETERMINISTIC** because keys are not relatedeach one
* **REMEMBER TO BACKUP** private keys!

## Deterministic wallet
* Use *n* words (**mnemonic words**) to create a **seed** used to generate **master private key**
* Master private key generate other private and public keys
* **DETERMINISTIC** Because you can generate all private keys knowind mnemonic words

## HD Wallets
* HD Wallets or Hierarchical Determinisic are wallet introduced with BIP32 and BIP44.
* They are a special kind of deterministic wallet
* They can derivate keys by other keys (*Master*, *Child*, *Grandchild*)

![](https://www.1daydude.com/wp-content/uploads/2018/10/HD-Deterministic-Wallets.png)
* With this kind of wallet we can handle many coins!

*(...we will see later in details...)*

# BIP
BIP are Bitcoin Improovements Proposal (informal proposal).

See https://github.com/bitcoin/bips

## BIP 39
Is becoming an industrial standard to handle mnemonic

https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki

Standard used to create deterministic keys by a wordlist.

It describe the implementation of mnemonic words for generation of deterministic wallets.

It consists of two parts: 
 1. Generating the mnemonic
 2. Converting mnemonic into a binary seed

This seed can be later used to generate deterministic wallets using BIP-0032 or similar methods.

### Process of generation
Better explained:
* **Nerd**:
   * https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki
   * https://www.youtube.com/watch?v=hRXcY_tIlrw

* **Dummyes**:
  * https://medium.com/coinmonks/mnemonic-generation-bip39-simply-explained-e9ac18db9477

Below I explained a "merge" of two:

#### Generating the mnemonic:
1. Generation of entropy. 
   * More entropy determine more security BUT longer words!
   * We generate an initial entropy random number with length **ENT** that is multiple of **32 bits** (128 to 256 bits are allowed).
   * The 128 to 256 bits take the possible to us to have 12 to 24 phrases
   * *-ex-* We take ENT=128 bits (12 phrases):
      * 063679ca1b28b5cfda9c186b367e271e (in hex format)
      * Completes 128 bites are:
      
      ```
      0 -> 0000
      6 -> 0110
      3 -> 0011
      ...
      1 -> 0001
      e -> 1110
      ```
2. Generation of checksum
   * An checksum is generated by taking first **CS = ENT/32** bits of sha256 of the random entropy.
   * *-ex-* We compute sha256 of random initial entropy
    
    ```

    sha256 = 
    = sha256(063679ca1b28b5cfda9c186b367e271e)
    = e6cb00ff75869bb1018d25af5c30ab0b059daaa3de6938252881e677b2eae068
    ```
    * Our checksum is the first **CS=128/32=4** bits of obtained sha256:
    ```

    e -> 1110 
    ```
    * Now we append checksum to the end of the random initial entropy:
    
    ```
    00000110001101100111100111001010000110110010100010110101110011111101101010011100000110000110101100110110011111100010011100011110 + 1110
    =
    000001100011011001111001110010100001101100101000101101011100111111011010100111000001100001101011001101100111111000100111000111101110
    ```

    * Now we split our final result in **groups of 11 bits**.
      * We choose 11 bits because they can represent a number from 0 to 2047.
      This number will be the index of word in the word list.
      * This is the most important part in which we pass from random number to words!
    ```
    00000110001 -> 49
    10110011110 -> 1438
    01110010100 -> 916
    ...
    00111101110 -> 494
    ```

    * With this indexs we are able to obtained (as i mentioned above) the words
       * The wordlists can be found here: https://github.com/bitcoin/bips/blob/master/bip-0039/bip-0039-wordlists.md (we use english wordlist)
       * **NOTE**: we obtain a 11 bit number thath come from 0 to 2047. The list has indexes from 1 to 2048, for this reason we must add 1 to obtained index

    ```
    00000110001 -> 49+1 -> alert
    10110011110 -> 1438+1 -> record
    01110010100 -> 916 -> income
    ...
    00111101110 -> 494 -> differ
    ```

    * **NOTE**: we can see that length of random entropy (ENT) influence **security** and **number of words**:

    ```
    |  ENT  | CS | ENT+CS |  MS  |         COMBINATIONS         |
    +-------+----+--------+------+------------------------------|
    |  128  |  4 |   132  |  12  |     2048^12 ~= 5.4*10^39     |
    |  160  |  5 |   165  |  15  |     2048^15 ~= 5.4*10^49     |
    |  192  |  6 |   198  |  18  |     2048^18 ~= 5.4*10^59     |
    |  224  |  7 |   231  |  21  |     2048^21 ~= 5.4*10^69     |
    |  256  |  8 |   264  |  24  |     2048^24 ~= 5.4*10^79     |

    Leggend:
    ENT -> length of entropy random numbers in bites
    CS -> checksum bites number
    MS -> max number of words
    COMBINATIONS -> number of way in which we can combine our words obtained
    ```

#### Converting mnemonic into a binary seed
* Last step is the creation of binary seed using word list.
* In this step an user can decide if set a **passphrase**.
   * If not setted, the passphrase will be an empty string.

* Morever we will se that we will use **PBKDF2** (Password-Based Key Derivation Function 2) function.
   * This function make the brute force dictionary attack very difficult

**NOTE**: Use a passphrase is better because prevent that an attacker who has your mnemonics words to stole your private keys!

Here we see the steps:

1. Concatenation of mnemonic words
    * Obtained our mnemonic words we must to concatenate
    * In our previous example:

    ```
    mnemonic_list = ["alert", "record", "income", ..., "differ"]

    THEN

    mnemonic_phrase = "alertrecordincome...differ" (UTF-8 NFKD format)
    ```

2. Use the passphrase
   * If passphrase is not setted, it will be "" (empty string). With this password we create the **salt**:

    ```
    salt = "mnemonic" + passphrase
    ```
   * Now we use PBKDF2 function to calculate random seed
      * See this link for more info: https://en.wikipedia.org/wiki/PBKDF2

    ```
    BINARY_SEED = PBKDF2(PRF, Password, Salt, c, dkLen)

    WHERE:
    - PRF: is the pseudorandom function.
        In our case HMAC-SHA512

    - Password: is the master password from which a derived key is generated. 
        In our case mnemonic_phrase (see above)

    - Salt: cryptographic salt. 
        In our case salt (see above)

    - c: is the number of iterations desired.
        In our case 2048 

    - dkLen: is the desired bit-length of the derived key.
        In our case 512 bits (= 64 bytes).
    ```

Now we have our **BINARY_SEED**. 

The BIP-39 is complete.

With BIP-39 we know "how to generate seed using a random wordlist and a optional passphrase".

Now with this seed we can use BIP-32 and BIP-44 to describe "how to generate a deterministic wallet (or Hierarchical deterministic wallet) with this seed obtained".

The last important thing to say of BIP-39 i that with differend passphrase we will generate different seeds, and with diferent seeds we will generate differents private/public key pairs.
 * This thing is very important to prevent by "$5 Wrench Attacks".
   * Go to https://blog.keys.casa/how-to-protect-your-bitcoin-from-5-wrench-attacks/ for more informations

![](https://blog.keys.casa/content/images/2020/04/xkcd.png)



## BIP 32